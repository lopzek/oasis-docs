---
order: 2 
title: Physics Manager 
type: Physics
---

PhysicsManager is used to manage all the physics components in the scene, and is responsible for communicating with the
physics backend to implement global operations related to the physics scene, such as updating and raycast.

## Physics update

The physical scene and the rendering scene are independent of each other, but their data are constantly synchronized
during the program execution. Therefore, as with scripts, the timing of synchronization is also very important.
Generally speaking, the update frequency of the physical scene is different from that of the rendering scene, which can
be set in the physics manager:

```ts
/** The fixed time step in seconds at which physics are performed. */
fixedTimeStep: number = 1 / 60;

/** The max sum of time step in seconds one frame. */
maxSumTimeStep: number = 1 / 3;
````

Every rendered frame, the physics engine is updated with a fixed time step `fixedTimeStep`, If it is less than a fixed
time step, it will be delayed to the next frame for processing. Therefore, each rendering frame, the physical scene may
be updated multiple times, so for the physical component update, it needs to be placed in a specific update
function, `Script` provides this interface:

```ts
export class Script extends Component {
  /**
   * Called before physics calculations, the number of times is related to the physical update frequency.
   */
  onPhysicsUpdate(): void {
  }
}
```

When the physical scene is updated, in addition to calling this function, it will also synchronize the posture of the
Collider and the Entity it is mounted on. The sequence of physical updates is as follows:

1. Call the user logic in `onPhysicsUpdate`.
2. `callColliderOnUpdate` synchronizes the new pose of the modified Entity to the physics collider.
3. Update the physics scene.
4. `callColliderOnLateUpdate` synchronizes the updated positions of all DynamicColliders to the corresponding Entity.

## Raycast

<playground src="physx-raycast.ts"></playground>

A ray can be understood as an unending line emitted from a point in a 3D world in one direction. Raycast is widely
used in 3D applications. Through ray casting, objects in the 3D scene can be picked up when the user taps the screen; it
can also be judged whether the bullet can hit the target in a shooting game.

![image.png](https://gw.alipayobjects.com/mdn/rms_d27172/afts/img/A*sr_IRYSLugMAAAAAAAAAAAAAARQnAQ)
(_The picture comes from the network_)

When using ray casting, first introduce the [Ray](${api}math/Ray) module in the code; then generate rays, which can be
generated by custom, or through the camera ([camera](${api}core/ Camera#viewportPointToRay)
) convert the screen input into rays; finally call the [PhysicsManager.raycast](${api}core/PhysicsManager#raycast)
method to detect the collider hit by the raycast. code show as below:

```typescript
// 加载 Raycast 模块
import {WebGLEngine, HitResult, Ray} from 'oasis-engine';
import {LitePhysics} from "@oasis-engine/physics-lite";

const engine = new WebGLEngine("canvas");
engine.physicsManager.initialize(LitePhysics);
engine.canvas.resizeByClientSize();

// 将屏幕输入转换成Ray
document.getElementById('canvas').addEventListener('click', (e) => {
  const ratio = window.devicePixelRatio;
  let ray = new Ray();
  camera.screenPointToRay(new Vector2(e.offsetX, e.offsetY).scale(ratio), ray);
  const hit = new HitResult();
  result = engine.physicsManager.raycast(ray, Number.MAX_VALUE, Layer.Everything, hit);
  if (result) {
    console.log(hit.entity.name);
  }
});
```

It should be pointed out that if you want to enable ray casting on an Entity, the Entity must have **Collider** ,
otherwise it will not trigger.

At the same time, in Oasis, InputManager is also provided, which encapsulates the input source and provides more
easy-to-use logic. The usage method can be [Reference](${docs}input) .
